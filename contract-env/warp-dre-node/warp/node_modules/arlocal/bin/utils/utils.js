"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.concatBuffers = exports.groupBy = exports.Utils = void 0;
const encoding_1 = require("./encoding");
class Utils {
    static randomID(len) {
        // tslint:disable-next-line: no-bitwise
        return [...Array(len || 43)].map(() => (~~(Math.random() * 36)).toString(36)).join('');
    }
    static atob(a) {
        return Buffer.from(a, 'base64').toString('binary');
    }
    static btoa(b) {
        return Buffer.from(b).toString('base64');
    }
    static tagValue(tags, name) {
        for (const tag of tags) {
            if ((0, encoding_1.fromB64Url)(tag.name).toString().toLowerCase() === name.toLowerCase()) {
                return (0, encoding_1.fromB64Url)(tag.value).toString();
            }
        }
        return '';
    }
}
exports.Utils = Utils;
const groupBy = (obj, key) => {
    return obj.reduce((rv, x) => {
        (rv[x[key]] = rv[x[key]] || []).push(x);
        return rv;
    }, {});
};
exports.groupBy = groupBy;
function concatBuffers(buffers) {
    let totalLength = 0;
    for (const buffer of buffers) {
        totalLength += buffer.byteLength;
    }
    const temp = new Uint8Array(totalLength);
    let offset = 0;
    temp.set(new Uint8Array(buffers[0]), offset);
    offset += buffers[0].byteLength;
    for (let i = 1; i < buffers.length; i++) {
        temp.set(new Uint8Array(buffers[i]), offset);
        offset += buffers[i].byteLength;
    }
    return temp;
}
exports.concatBuffers = concatBuffers;
//# sourceMappingURL=utils.js.map