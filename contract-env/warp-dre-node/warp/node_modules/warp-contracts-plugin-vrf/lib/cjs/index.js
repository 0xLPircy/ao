"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VRFPlugin = void 0;
const warp_contracts_1 = require("warp-contracts");
const elliptic_1 = __importDefault(require("elliptic"));
const arweave_1 = __importDefault(require("arweave"));
const vrf_js_1 = require("@idena/vrf-js");
const EC = new elliptic_1.default.ec('secp256k1');
const key = EC.genKeyPair();
const pubKeyS = key.getPublic(true, 'hex');
class VRFPlugin {
    type() {
        return 'vrf';
    }
    process() {
        return {
            generateMockVrf(sortKey) {
                const data = arweave_1.default.utils.stringToBuffer(sortKey);
                const [index, proof] = (0, vrf_js_1.Evaluate)(key.getPrivate().toArray(), data);
                return {
                    index: arweave_1.default.utils.bufferTob64Url(index),
                    proof: arweave_1.default.utils.bufferTob64Url(proof),
                    bigint: (0, warp_contracts_1.bufToBn)(index).toString(),
                    pubkey: pubKeyS
                };
            },
            verify(vrf, sortKey) {
                const keys = EC.keyFromPublic(vrf.pubkey, 'hex');
                let hash;
                try {
                    // ProofHoHash throws its own 'invalid vrf' exception
                    hash = (0, vrf_js_1.ProofHoHash)(keys.getPublic(), arweave_1.default.utils.stringToBuffer(sortKey), arweave_1.default.utils.b64UrlToBuffer(vrf.proof));
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                }
                catch (e) {
                    return false;
                }
                return arweave_1.default.utils.bufferTob64Url(hash) == vrf.index;
            }
        };
    }
}
exports.VRFPlugin = VRFPlugin;
//# sourceMappingURL=index.js.map